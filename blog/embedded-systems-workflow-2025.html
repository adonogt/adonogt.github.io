<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>グスターボ | embedded systems workflow 2025</title>
    <link rel="icon" href="../assets/images/favicon.png" type="image/png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="../assets/css/layout.css">
    <link rel="stylesheet" href="../assets/css/blog.css">
</head>
<body>
    <div class="container">
        <header>

            <nav>
                <a href="../index.html" class="nav-link nav-icon">
                    <img src="../assets/images/favicon.png" alt="About" title="グスターボ">
                </a>
                <a href="../blog/index.html" class="nav-link">blog</a>
                <a href="index.html" class="nav-link active">projects</a>
                <a href="../gear.html" class="nav-link">gear</a>
                <a href="../contact.html" class="nav-link">contact</a>
            </nav>
        </header>

        <article class="post-article">
            <div class="post-header">
                <h1 class="post-title">embedded systems workflow 2025</h1>
                <div class="post-date">january 08, 2025</div>
            </div>

            <div class="post-content">
                <h2>introduction</h2>
                <p>This guide covers setting up a complete embedded development environment on Arch Linux with i3wm, focusing on STM32 and Renesas microcontrollers. We'll configure everything needed to program, debug, and monitor embedded code using Neovim and J-Link instead of traditional IDEs.</p>
                
                <p>The workflow emphasizes command-line tools, terminal-based debugging, and efficient keyboard-driven development that integrates seamlessly with the i3 window manager philosophy.</p>

                <h2>base system setup</h2>
                <p>Start with a clean Arch Linux installation running i3wm. We'll install the fundamental tools that form the foundation of our embedded workflow.</p>
                
                <pre><code># Update system and install base development tools
sudo pacman -Syu
sudo pacman -S base-devel git wget curl unzip

# Install AUR helper for additional packages
git clone https://aur.archlinux.org/yay.git
cd yay && makepkg -si && cd .. && rm -rf yay</code></pre>

                <h3>terminal and shell configuration</h3>
                <p>Configure a powerful terminal environment that supports our embedded workflow:</p>

                <pre><code># Install terminal emulator and shell tools
sudo pacman -S alacritty zsh tmux

# Install oh-my-zsh for better shell experience
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"

# Install useful zsh plugins
git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</code></pre>

                <h2>arm toolchain installation</h2>
                <p>Install the ARM cross-compilation toolchain for STM32 and other ARM Cortex-M microcontrollers.</p>

                <h3>gcc arm toolchain</h3>
                <pre><code># Install ARM GCC toolchain from official repositories
sudo pacman -S arm-none-eabi-gcc arm-none-eabi-gdb arm-none-eabi-newlib

# Verify installation
arm-none-eabi-gcc --version
arm-none-eabi-gdb --version

# Install additional tools for binary manipulation
sudo pacman -S arm-none-eabi-binutils</code></pre>

                <h3>j-link tools installation</h3>
                <p>Install J-Link tools for programming and debugging both STM32 and Renesas microcontrollers:</p>

                <pre><code># Install J-Link software from AUR
yay -S jlink-software-and-documentation

# Install STM32CubeMX for code generation (optional but useful)
yay -S stm32cubemx

# Install OpenOCD with J-Link support
sudo pacman -S openocd

# Test J-Link connection (with board connected)
JLinkExe -device STM32F407VG -if SWD -speed 4000 -autoconnect 1

# For Renesas devices
JLinkExe -device R7FA6M3AH3CFC -if SWD -speed 4000</code></pre>

                <h2>renesas toolchain setup</h2>
                <p>Configure tools for Renesas microcontrollers, focusing on the RA and RX families with J-Link support.</p>

                <h3>renesas gcc toolchain</h3>
                <pre><code># Download Renesas GCC toolchain for RA family
# Note: This typically requires manual download from Renesas website
# Create directory for Renesas tools
sudo mkdir -p /opt/renesas

# Extract and install toolchain (adjust path as needed)
# sudo tar -xzf renesas-toolchain.tar.gz -C /opt/renesas/

# Add to PATH in ~/.zshrc
echo 'export PATH="/opt/renesas/bin:$PATH"' >> ~/.zshrc
source ~/.zshrc</code></pre>

                <h3>j-link support for renesas</h3>
                <p>Configure J-Link for Renesas microcontroller programming and debugging:</p>

                <pre><code># Test J-Link connection with Renesas RA device
JLinkExe -device R7FA6M3AH3CFC -if SWD -speed 4000

# Test with RX device
JLinkExe -device R5F565NE -if FINE -speed 4000

# Install Renesas specific J-Link scripts
# These are typically included with J-Link software package

# Verify J-Link can detect both device families
JLinkExe -CommanderScript test_connection.jlink</code></pre>

                <h2>neovim configuration for embedded development</h2>
                <p>Configure Neovim with plugins and settings optimized for embedded C development, including LSP support, syntax highlighting, and debugging integration.</p>

                <h3>neovim installation and basic setup</h3>
                <pre><code># Install Neovim and dependencies
sudo pacman -S neovim nodejs npm python python-pip ripgrep fd

# Install Python support for Neovim
pip install pynvim

# Create Neovim configuration directory
mkdir -p ~/.config/nvim</code></pre>

                <h3>neovim configuration file</h3>
                <p>Create a comprehensive Neovim configuration for embedded development:</p>

                <pre><code>-- ~/.config/nvim/init.lua

-- Basic settings
vim.opt.number = true
vim.opt.relativenumber = true
vim.opt.tabstop = 4
vim.opt.shiftwidth = 4
vim.opt.expandtab = true
vim.opt.smartindent = true
vim.opt.wrap = false
vim.opt.swapfile = false
vim.opt.backup = false
vim.opt.hlsearch = false
vim.opt.incsearch = true
vim.opt.termguicolors = true
vim.opt.scrolloff = 8
vim.opt.signcolumn = "yes"
vim.opt.colorcolumn = "80"

-- Set leader key
vim.g.mapleader = " "

-- Key mappings for embedded development
vim.keymap.set("n", "<leader>mm", ":!make<CR>")
vim.keymap.set("n", "<leader>mc", ":!make clean<CR>")
vim.keymap.set("n", "<leader>mf", ":!make flash<CR>")
vim.keymap.set("n", "<leader>md", ":!make debug<CR>")
vim.keymap.set("n", "<leader>jr", ":!JLinkExe<CR>")

-- Buffer navigation
vim.keymap.set("n", "<leader>bn", ":bnext<CR>")
vim.keymap.set("n", "<leader>bp", ":bprev<CR>")

-- Split navigation
vim.keymap.set("n", "<C-h>", "<C-w>h")
vim.keymap.set("n", "<C-j>", "<C-w>j")
vim.keymap.set("n", "<C-k>", "<C-w>k")
vim.keymap.set("n", "<C-l>", "<C-w>l")</code></pre>

                <h3>lsp configuration for c/c++</h3>
                <p>Configure Language Server Protocol for C/C++ development with embedded-specific settings:</p>

                <pre><code># Install clangd for C/C++ LSP support
sudo pacman -S clang

# Install LSP plugins (add to init.lua)
# This requires a plugin manager like Packer or Lazy.nvim</code></pre>

                <p>Add LSP configuration to your Neovim setup:</p>

                <pre><code>-- LSP configuration for embedded C development
local lspconfig = require('lspconfig')

lspconfig.clangd.setup({
  cmd = {
    "clangd",
    "--background-index",
    "--clang-tidy",
    "--header-insertion=iwyu",
    "--cross-file-rename",
    "--completion-style=detailed",
  },
  init_options = {
    clangdFileStatus = true,
    usePlaceholders = true,
    completeUnimported = true,
    semanticHighlighting = true,
  },
})</code></pre>

                <h2>project structure and build system</h2>
                <p>Set up a standardized project structure and build system that works efficiently with our terminal-based workflow and J-Link tools.</p>

                <h3>stm32 project template</h3>
                <p>Create a template structure for STM32 projects with J-Link integration:</p>

                <pre><code># Create project directory structure
mkdir -p ~/embedded/stm32-template/{src,inc,lib,build,docs,scripts}

# Navigate to project directory
cd ~/embedded/stm32-template</code></pre>

                <p>Create a Makefile optimized for J-Link workflow:</p>

                <pre><code># STM32 Makefile Template with J-Link support

TARGET = main
BUILD_DIR = build

# Source files
C_SOURCES = src/main.c src/system.c
ASM_SOURCES = startup_stm32f4xx.s

# Include directories
C_INCLUDES = -Iinc -Ilib/CMSIS/Include -Ilib/STM32F4xx_HAL_Driver/Inc

# Compiler and tools
PREFIX = arm-none-eabi-
CC = $(PREFIX)gcc
AS = $(PREFIX)gcc -x assembler-with-cpp
CP = $(PREFIX)objcopy
SZ = $(PREFIX)size
AR = $(PREFIX)ar
GDB = $(PREFIX)gdb

# MCU settings
MCU = -mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard

# Compile flags
CFLAGS = $(MCU) $(C_INCLUDES) -Wall -fdata-sections -ffunction-sections
CFLAGS += -g -gdwarf-2 -O0

# Link flags
LDFLAGS = $(MCU) -specs=nano.specs -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref -Wl,--gc-sections

# Build targets
all: $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).bin

$(BUILD_DIR)/%.o: src/%.c | $(BUILD_DIR)
	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(<:.c=.lst) $< -o $@

$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) Makefile
	$(CC) $(OBJECTS) $(LDFLAGS) -o $@
	$(SZ) $@

$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR)
	$(CP) -O ihex $< $@

$(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR)
	$(CP) -O binary -S $< $@

$(BUILD_DIR):
	mkdir $@

clean:
	-rm -fR $(BUILD_DIR)

# J-Link flash command
flash: $(BUILD_DIR)/$(TARGET).hex
	JLinkExe -device STM32F407VG -if SWD -speed 4000 -CommanderScript scripts/flash.jlink

# J-Link debug session
debug: $(BUILD_DIR)/$(TARGET).elf
	JLinkGDBServer -device STM32F407VG -if SWD -speed 4000 &
	sleep 2
	$(GDB) -ex "target remote localhost:2331" $<

.PHONY: all clean flash debug</code></pre>

                <h3>j-link script files</h3>
                <p>Create J-Link commander script files for automated flashing:</p>

                <pre><code># Create scripts directory and flash script
mkdir -p scripts
cat > scripts/flash.jlink << 'EOF'
r
h
loadfile build/main.hex
r
g
qc
EOF

# Create debug script for J-Link
cat > scripts/debug.jlink << 'EOF'
r
h
loadfile build/main.elf
SetPC Reset_Handler
EOF</code></pre>

                <h3>compile_commands.json generation</h3>
                <p>Generate compile_commands.json for better LSP integration:</p>

                <pre><code># Install bear for compile_commands.json generation
sudo pacman -S bear

# Generate compile database
bear -- make

# This creates compile_commands.json for clangd</code></pre>

                <h2>debugging workflow with j-link</h2>
                <p>Set up an efficient debugging workflow using J-Link GDB Server and GDB in terminal, integrated with tmux for multiple panes.</p>

                <h3>j-link gdb server configuration</h3>
                <p>Configure J-Link GDB Server for both STM32 and Renesas targets:</p>

                <pre><code># Create J-Link GDB Server startup script for STM32
cat > ~/scripts/jlink-gdb-stm32.sh << 'EOF'
#!/bin/bash
echo "Starting J-Link GDB Server for STM32..."
JLinkGDBServer -device STM32F407VG -if SWD -speed 4000 -port 2331
EOF

# Create J-Link GDB Server startup script for Renesas RA
cat > ~/scripts/jlink-gdb-renesas.sh << 'EOF'
#!/bin/bash
echo "Starting J-Link GDB Server for Renesas RA..."
JLinkGDBServer -device R7FA6M3AH3CFC -if SWD -speed 4000 -port 2332
EOF

# Make scripts executable
chmod +x ~/scripts/jlink-gdb-*.sh</code></pre>

                <h3>gdb configuration for embedded debugging</h3>
                <p>Configure GDB for embedded debugging with J-Link specific commands and settings:</p>

                <pre><code># Create ~/.gdbinit for embedded debugging
cat > ~/.gdbinit << 'EOF'
set history save on
set print pretty on
set print array on
set print array-indexes on
set print elements 0
set print repeats 0

# Connect to J-Link GDB Server
define jconnect
    target remote localhost:2331
    monitor reset
    monitor halt
    load
end

# Connect to Renesas target
define jconnect_renesas
    target remote localhost:2332
    monitor reset
    monitor halt
    load
end

# Reset and run
define restart
    monitor reset
    continue
end

# Show peripheral registers (example for STM32)
define show_periph
    x/16wx 0x40020000
end

# Memory dump helpers
define dump_flash
    dump ihex memory firmware_dump.hex 0x08000000 0x08100000
end

define dump_ram
    dump binary memory ram_dump.bin 0x20000000 0x20020000
end

# J-Link specific commands
define jlink_info
    monitor jlink_info
end

define jlink_speed
    monitor speed 4000
end
EOF</code></pre>

                <h2>development workflow integration</h2>
                <p>Create scripts and tmux sessions that streamline the development process from coding to debugging using J-Link tools.</p>

                <h3>tmux session automation</h3>
                <p>Create a tmux script for embedded development sessions:</p>

                <pre><code>#!/bin/bash
# ~/scripts/embedded-session.sh

SESSION_NAME="embedded-dev"

# Check if session exists
tmux has-session -t $SESSION_NAME 2>/dev/null

if [ $? != 0 ]; then
    # Create new session with multiple panes
    tmux new-session -d -s $SESSION_NAME -x 120 -y 30

    # Split into 4 panes
    tmux split-window -h -t $SESSION_NAME:0
    tmux split-window -v -t $SESSION_NAME:0.0
    tmux split-window -v -t $SESSION_NAME:0.2

    # Configure panes
    tmux send-keys -t $SESSION_NAME:0.0 'nvim .' C-m
    tmux send-keys -t $SESSION_NAME:0.1 'make clean && make' C-m
    tmux send-keys -t $SESSION_NAME:0.2 '~/scripts/jlink-gdb-stm32.sh'
    tmux send-keys -t $SESSION_NAME:0.3 'arm-none-eabi-gdb'

    # Select first pane
    tmux select-pane -t $SESSION_NAME:0.0
fi

# Attach to session
tmux attach-session -t $SESSION_NAME</code></pre>

                <h3>build and flash automation with j-link</h3>
                <p>Create helper scripts for common development tasks using J-Link:</p>

                <pre><code>#!/bin/bash
# ~/scripts/jlink-flash.sh

set -e

PROJECT_TYPE=${1:-stm32}  # stm32 or renesas

if [ "$PROJECT_TYPE" = "stm32" ]; then
    DEVICE="STM32F407VG"
    INTERFACE="SWD"
elif [ "$PROJECT_TYPE" = "renesas" ]; then
    DEVICE="R7FA6M3AH3CFC"
    INTERFACE="SWD"
else
    echo "Usage: $0 [stm32|renesas]"
    exit 1
fi

echo "Building project..."
make clean
make -j$(nproc)

echo "Flashing to $DEVICE via J-Link..."
JLinkExe -device $DEVICE -if $INTERFACE -speed 4000 -CommanderScript scripts/flash.jlink

echo "Flash complete. Device reset and running."</code></pre>

                <h2>monitoring and analysis tools</h2>
                <p>Set up tools for monitoring embedded systems, analyzing performance, and debugging runtime issues using J-Link's advanced features.</p>

                <h3>j-link rtt (real time transfer)</h3>
                <p>Configure J-Link RTT for real-time debugging output:</p>

                <pre><code># Install J-Link RTT Viewer
# This is included with J-Link software package

# Start RTT session
JLinkRTTClient

# Alternative: Use RTT with GDB
# Add to your C code for RTT output:</code></pre>

                <pre><code>// Add to your embedded C project
#include "SEGGER_RTT.h"

int main(void) {
    // Initialize RTT
    SEGGER_RTT_Init();
    
    // Your main code here
    while(1) {
        SEGGER_RTT_printf(0, "Debug message: %d\n", counter++);
        HAL_Delay(1000);
    }
}</code></pre>

                <h3>serial communication</h3>
                <p>Configure tools for UART/serial communication:</p>

                <pre><code># Install serial communication tools
sudo pacman -S minicom picocom screen

# Add user to dialout group for serial access
sudo usermod -aG uucp $USER

# Create picocom alias for common settings
echo 'alias serial="picocom -b 115200 /dev/ttyUSB0"' >> ~/.zshrc

# Configure minicom (run once)
sudo minicom -s</code></pre>

                <h3>logic analyzer integration</h3>
                <p>Install tools for logic analyzer integration and signal analysis:</p>

                <pre><code># Install sigrok for logic analyzer support
sudo pacman -S sigrok-cli pulseview

# Install additional protocol decoders
sudo pacman -S libsigrokdecode

# Test installation
sigrok-cli --list-supported

# Install additional tools for signal analysis
yay -S saleae-logic</code></pre>

                <h2>i3wm integration and workflow</h2>
                <p>Configure i3wm to optimize the embedded development workflow with proper window management and keybindings for J-Link tools.</p>

                <h3>i3 configuration for embedded development</h3>
                <p>Add embedded-specific keybindings to your i3 config:</p>

                <pre><code># Add to ~/.config/i3/config

# Embedded development bindings
bindsym $mod+e exec ~/scripts/embedded-session.sh
bindsym $mod+Shift+f exec ~/scripts/jlink-flash.sh stm32
bindsym $mod+Shift+r exec ~/scripts/jlink-flash.sh renesas
bindsym $mod+Shift+s exec alacritty -e picocom -b 115200 /dev/ttyUSB0
bindsym $mod+Shift+j exec JLinkRTTViewer

# Workspace assignments for embedded development
assign [class="^STM32CubeIDE$"] workspace number 3
assign [class="^PulseView$"] workspace number 4
assign [class="^JLinkRTTViewer$"] workspace number 5

# Floating windows for debugging tools
for_window [title="^arm-none-eabi-gdb"] floating enable
for_window [class="^STM32CubeMX$"] floating enable
for_window [class="^JLinkExe$"] floating enable
for_window [class="^JLinkRTTViewer$"] floating enable</code></pre>

                <h3>workspace organization</h3>
                <p>Organize workspaces for efficient embedded development:</p>

                <pre><code># Workspace layout example:
# Workspace 1: Code (Neovim)
# Workspace 2: Build and Terminal
# Workspace 3: Documentation and Datasheets  
# Workspace 4: Hardware Tools (Logic Analyzer, Oscilloscope)
# Workspace 5: J-Link Tools (RTT Viewer, Commander)

# Add workspace naming to i3 config
set $ws1 "1:code"
set $ws2 "2:build" 
set $ws3 "3:docs"
set $ws4 "4:hardware"
set $ws5 "5:jlink"</code></pre>

                <h2>project examples and templates</h2>
                <p>Create practical examples that demonstrate the complete workflow from project setup to debugging using J-Link tools.</p>

                <h3>stm32 blinky example</h3>
                <p>A complete STM32 project example with our J-Link workflow:</p>

                <pre><code>// src/main.c - STM32F4 Blinky Example with RTT
#include "stm32f4xx_hal.h"
#include "SEGGER_RTT.h"

void SystemClock_Config(void);
static void MX_GPIO_Init(void);
void Error_Handler(void);

int main(void) {
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    
    // Initialize RTT for debugging output
    SEGGER_RTT_Init();
    SEGGER_RTT_printf(0, "STM32F4 Blinky Started\n");

    uint32_t counter = 0;
    
    while (1) {
        HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_12);
        SEGGER_RTT_printf(0, "Blink #%lu\n", counter++);
        HAL_Delay(500);
    }
}

static void MX_GPIO_Init(void) {
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    __HAL_RCC_GPIOD_CLK_ENABLE();

    GPIO_InitStruct.Pin = GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
}

void SystemClock_Config(void) {
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    __HAL_RCC_PWR_CLK_ENABLE();
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
    RCC_OscInitStruct.PLL.PLLM = 8;
    RCC_OscInitStruct.PLL.PLLN = 336;
    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
    RCC_OscInitStruct.PLL.PLLQ = 7;
    
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
        Error_Handler();
    }

    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
                                | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
    
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) {
        Error_Handler();
    }
}

void Error_Handler(void) {
    __disable_irq();
    SEGGER_RTT_printf(0, "Error Handler Called!\n");
    while (1) {
        // Error handling
    }
}</code></pre>

                <h3>renesas ra example</h3>
                <p>Example project for Renesas RA microcontroller:</p>

                <pre><code>// src/main.c - Renesas RA6M3 Blinky Example
#include "hal_data.h"
#include "SEGGER_RTT.h"

void R_BSP_WarmStart(bsp_warm_start_event_t event);

int main(void) {
    fsp_err_t err = FSP_SUCCESS;
    
    // Initialize the BSP
    err = R_BSP_Init();
    if (FSP_SUCCESS != err) {
        while(1);
    }
    
    // Initialize RTT
    SEGGER_RTT_Init();
    SEGGER_RTT_printf(0, "Renesas RA6M3 Blinky Started\n");
    
    // Initialize GPT for LED control
    err = R_GPT_Open(&g_timer0_ctrl, &g_timer0_cfg);
    if (FSP_SUCCESS != err) {
        SEGGER_RTT_printf(0, "Timer initialization failed\n");
        while(1);
    }
    
    // Start timer
    err = R_GPT_Start(&g_timer0_ctrl);
    if (FSP_SUCCESS != err) {
        while(1);
    }

    uint32_t counter = 0;
    
    while (1) {
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_01_PIN_06, BSP_IO_LEVEL_HIGH);
        R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
        
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_01_PIN_06, BSP_IO_LEVEL_LOW);
        R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
        
        SEGGER_RTT_printf(0, "RA Blink #%lu\n", counter++);
    }
}

void R_BSP_WarmStart(bsp_warm_start_event_t event) {
    if (BSP_WARM_START_RESET == event) {
        // Pre-clock initialization
    }
    if (BSP_WARM_START_POST_C == event) {
        // Post-clock initialization
    }
}</code></pre>

                <h2>advanced debugging techniques</h2>
                <p>Explore advanced debugging capabilities available with J-Link and our terminal-based setup.</p>

                <h3>j-link trace and profiling</h3>
                <p>Use J-Link's advanced tracing capabilities for performance analysis:</p>

                <pre><code># Enable SWO trace for STM32
JLinkSWOViewer -device STM32F407VG -swofreq 2000000

# Create GDB script for trace analysis
cat > scripts/trace.gdb << 'EOF'
# Connect to target
target remote localhost:2331
monitor reset
load

# Enable SWO trace
monitor SWO EnableTarget 72000000 2000000 1 0

# Set breakpoints for profiling
break main
break HAL_GPIO_TogglePin

# Start trace
monitor SWO Start

continue
EOF</code></pre>

                <h3>memory analysis and optimization</h3>
                <p>Tools and techniques for analyzing memory usage and optimizing embedded code:</p>

                <pre><code># Analyze memory usage
arm-none-eabi-size build/main.elf

# Generate memory map
arm-none-eabi-objdump -h build/main.elf

# Disassemble for optimization analysis
arm-none-eabi-objdump -D build/main.elf > build/disassembly.txt

# Create memory analysis script
cat > ~/scripts/memory-analysis.sh << 'EOF'
#!/bin/bash
echo "=== Memory Usage Analysis ==="
arm-none-eabi-size build/main.elf

echo -e "\n=== Section Headers ==="
arm-none-eabi-objdump -h build/main.elf

echo -e "\n=== Symbol Table (largest symbols) ==="
arm-none-eabi-nm --size-sort -r build/main.elf | head -20
EOF</code></pre>

                <h2>troubleshooting and optimization</h2>
                <p>Common issues and solutions when working with J-Link and this embedded development setup.</p>

                <h3>j-link connection issues</h3>
                <p>Solutions for typical J-Link connection problems:</p>

                <pre><code># Check J-Link detection
lsusb | grep "SEGGER"

# Reset J-Link if connection fails
JLinkExe -CommanderScript reset.jlink

# Create reset script
cat > reset.jlink << 'EOF'
r
h
exit
EOF

# Permission issues
sudo usermod -aG plugdev $USER
sudo udevadm control --reload-rules

# J-Link firmware update
JLinkExe -UpdateFirmware</code></pre>

                <h3>debugging common embedded issues</h3>
                <p>Systematic approach to debugging embedded code issues:</p>

                <pre><code># Create debugging helper script
cat > ~/scripts/debug-helper.sh << 'EOF'
#!/bin/bash

echo "=== J-Link Debugging Helper ==="
echo "1. Check J-Link connection"
JLinkExe -CommanderScript check.jlink

echo "2. Verify target power"
echo "3. Check reset line"
echo "4. Verify clock configuration"

echo "Starting GDB with automatic setup..."
arm-none-eabi-gdb build/main.elf -ex "jconnect" -ex "info registers"
EOF</code></pre>

                <h3>performance optimization</h3>
                <p>Optimize the development environment for better performance:</p>

                <pre><code># Optimize Neovim startup time
# Add to init.lua
vim.opt.updatetime = 100
vim.opt.timeoutlen = 500

# Use faster grep alternatives
echo 'alias grep="rg"' >> ~/.zshrc
echo 'alias find="fd"' >> ~/.zshrc

# Optimize compilation with ccache
sudo pacman -S ccache
export CC="ccache arm-none-eabi-gcc"
export CXX="ccache arm-none-eabi-g++"

# J-Link speed optimization
# Add to J-Link scripts for maximum speed
echo "speed 4000" >> scripts/flash.jlink</code></pre>

                <h2>version control and project management</h2>
                <p>Best practices for managing embedded projects with version control and collaboration.</p>

                <h3>git configuration for embedded projects</h3>
                <pre><code># Create .gitignore for embedded projects
cat > .gitignore << 'EOF'
# Build artifacts
build/
*.o
*.elf
*.bin
*.hex
*.map
*.lst

# IDE files
.vscode/
.settings/
.metadata/

# J-Link files
JLinkLog.txt
JLinkSettings.ini

# Temporary files
*~
.#*
#*#

# OS specific
.DS_Store
Thumbs.db
EOF

# Configure git hooks for embedded projects
cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash
# Run static analysis before commit
make clean && make
if [ $? -ne 0 ]; then
    echo "Build failed. Commit aborted."
    exit 1
fi
EOF

chmod +x .git/hooks/pre-commit</code></pre>

                <h2>continuous integration setup</h2>
                <p>Set up automated testing and building for embedded projects.</p>

                <h3>github actions for embedded ci</h3>
                <pre><code># .github/workflows/embedded-ci.yml
name: Embedded CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install ARM toolchain
      run: |
        sudo apt-get update
        sudo apt-get install gcc-arm-none-eabi
    
    - name: Build project
      run: |
        make clean
        make -j$(nproc)
    
    - name: Run static analysis
      run: |
        sudo apt-get install cppcheck
        cppcheck --enable=all --error-exitcode=1 src/
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: firmware
        path: build/*.hex</code></pre>

                <h2>conclusion</h2>
                <p>This embedded systems workflow provides a powerful, keyboard-driven development environment using J-Link tools that integrates seamlessly with Arch Linux and i3wm. The setup enables efficient development of both STM32 and Renesas microcontroller projects without the overhead of traditional IDEs.</p>

                <p>The J-Link integration offers superior debugging capabilities including Real-Time Transfer (RTT), SWO trace, and reliable programming across multiple microcontroller families. The workflow emphasizes terminal-based tools, scriptable automation, and efficient window management that scales well for complex embedded projects.</p>

                <p>Regular practice with the keyboard shortcuts, tmux commands, and J-Link tools will significantly boost productivity. The RTT integration particularly transforms the debugging experience, providing real-time printf-style debugging without the overhead of traditional serial communication.</p>

                <p>For advanced usage, consider adding code analyzers like cppcheck, memory debugging with J-Link trace capabilities, and continuous integration pipelines for automated testing and deployment across your target hardware platforms.</p>
                
                <div class="post-meta" style="margin-top: 48px; text-align: center; padding-top: 32px; border-top: 1px solid #e5e5e5;">
                    <a href="blog.html" class="back-link">← back to blog</a>
                </div>
            </div>
        </article>

        <footer>
            <div class="copyright">
                アドノグスターボ © 2025
            </div>
        </footer>
    </div>
</body>
</html>
